#! /usr/bin/env python3
import numpy as np

from aiida import orm
from aiida.engine import calcfunction


@calcfunction
def kmapper(
    dense_mesh: orm.KpointsData,
    coarse_mesh: orm.KpointsData,
    start_band: orm.Int,
    end_band: orm.Int,
) -> orm.List:
    """Find the mapping between kpoints in coarse mesh and a dense mesh.

    :param dense_mesh: usually a ``calc.outputs.output_band`` representing a pw.x symmetry-reduced grid in an IBZ but with larger density.
    :type dense_mesh: orm.KpointsData
    :param coarse_mesh: usually a ``KpointsData`` representing a uniform grid generated by ``wannier90/kmesh.pl``.
    :type coarse_mesh: orm.KpointsData
    :param start_band: index of start band for yambo to compute QP correction
    :type start_band: orm.Int
    :param end_band: index of end band for yambo to compute QP correction
    :type end_band: orm.Int
    :return: The ``QPkrange`` for yambo, i.e. a list of ``kpoint|kpoint|start_band|end_band``
    :rtype: orm.List
    """
    coarse_mesh = coarse_mesh.get_kpoints()
    dense_mesh = dense_mesh.get_kpoints()

    opt = np.array([0, 1, -1])
    k_list = []
    for i in coarse_mesh:
        count = 1
        for j in dense_mesh:
            q = i - j
            q = np.around(q, decimals=5)
            if (q[0] in opt and q[1] in opt and q[2] in opt):
                k_list.append(count)
            count = count + 1
    if len(coarse_mesh) == len(dense_mesh[np.array(k_list) - 1]):
        print('Grids are commensurate')
    else:
        print('Grids are not commensurate')

    qpkrange = [(_, _, start_band.value, end_band.value) for _ in k_list]

    return orm.List(list=qpkrange)
